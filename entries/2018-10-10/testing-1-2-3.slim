<h1 class="mb-0">
  = meta.title
</h1>

<small class="text-muted">
  = "Published: " + meta.publication_time.to_s
</small>

markdown:
  Here's a quick test of my setup.

  ## Proof that $\sqrt{2}$ is irrational

  Let's test that MathJax is setup correctly.

  Say that $\sqrt{2}$ were rational. We will aim to produce a
  contradiction. Then the definition of rationality implies that:

  $$\sqrt{2} = \frac{a}{b}$$

  for some $a, b$ integers. Further, we may assume that the fraction is
  in lowest terms, which means that $a, b$ share no factors.

  Now, squaring both sides tells us:

  $$
    \begin{align}
      \sqrt{2} &= \frac{a}{b}\\
      2 &= \frac{a^2}{b^2}\\
      2 b^2 &= a^2
    \end{align}
  $$

  This implies that 2 is a factor of $a^2$.

  Note that, if the prime factorization of $a$ is:

  $$
    \begin{align}
      a = p_1^{k_1} p_2^{k_2} \cdots p_n^{k_n}
    \end{align}
  $$

  then this implies

  $$
    \begin{align}
      a^2 = p_1^{2k_1} p_2^{2k_2} \cdots p_n^{2k_n}
    \end{align}
  $$

  Note first: any prime factor $p_i$ of $a^2$ is also a factor of $a$.

  More, if $p_i$ is a prime factor which divides $a^2$, than in fact we
  must have $p_i^2$ divides $a^2$. And since we know that 2 divides
  $a^2$, then so must $2^2 = 4$. Which allows us to say that
  $\frac{a^2}{2}$ should still be divisible by 2.

  But note: $b^2 = \frac{a^2}{2}$. So therefore $b^2$ should be
  divisible by 2. But we already said about prime factors of squares: if
  2 divides $b^2$, then it must also divide $b$.

  That would contradict our choice that $a, b$ had no common factors.

  Therefore we have established the contradiction. It must not be
  possible to write $\sqrt{2}$ as $\frac{a}{b}$, which means $\sqrt{2}$
  was not rational in the first place.

  ## Code highlighting

  Let's test out code highlighting for some Haskell code.

  ```haskell
  qsort :: ArraySlice -> IO ()
  qsort as
    | (asLength as) == 0 = do
        return ()
    | otherwise = do
        pivotIdx <- partition as 0 0
        let leftLen = pivotIdx
        qsort (resliceArraySlice as 0 leftLen)
        let rightLen = (asLength as) - (pivotIdx + 1)
        qsort (resliceArraySlice as (pivotIdx + 1) rightLen)
  ```

  Look at that! Wow oh wow! How about some C++?

  ```cpp
  void sort(std::vector<int>& nums, int start, int len) {
    if (len == 0) {
      return;
    }

    int pivotIdx = start;
    const int pivot = nums[pivotIdx];
    for (int idx = start; idx < start+len; idx += 1) {
      int val = nums[idx];
      if (pivot <= val) {
        continue;
      }

      nums[pivotIdx] = val;
      nums[idx] = nums[pivotIdx + 1];
      nums[pivotIdx + 1] = pivot;
      pivotIdx += 1;
    }

    int numLeft = pivotIdx - start;
    int numRight = (start + len) - (pivotIdx + 1);

    // printVector(nums);
    if (numLeft > 0) {
      sort(nums, start, numLeft);
    }
    if (numRight > 0) {
      sort(nums, pivotIdx + 1, numRight);
    }
  }
  ```

  Okay, all done! Let's just finally check out some comments!
